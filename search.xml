<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis框架小结]]></title>
    <url>%2F2017%2F10%2F31%2FMyBatis%2F</url>
    <content type="text"><![CDATA[学习MyBatis的一些个人总结 MyBatis环境配置 1 导入jar包 2 log4j.properties 3 sqlMapConfig.xml 12345678910111213141516171819202122232425262728293031&lt;configuration&gt;&lt;!-- 先加载property，再加载properties,后加载覆盖--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;jdbc.driver&quot; value=&quot;AAA&quot;/&gt;&lt;/properties&gt;&lt;!-- 配置pojo别名--&gt; &lt;typeAliases&gt; &lt;!--&lt;typeAlias type=&quot;com.misaniy.po.User&quot; alias=&quot;user&quot; /&gt;--&gt; &lt;!-- 单个配置typeAlias 扫描包package，不区分大小写 --&gt; &lt;package name=&quot;com.misaniy.po&quot; /&gt;&lt;/typeAliases&gt;&lt;enviroments default=&quot;development&quot;&gt; &lt;enviroment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;/dataSource&gt; &lt;/enviroment&gt;&lt;/enviroments&gt;&lt;mappers&gt; &lt;!-- resource根据classpath查找，url绝对路径,class，接口全限定名（目录相同、名称一致、）、package扫描包 --&gt; &lt;mapper class=&quot;com.misaniy.mapper.UserMapper&quot; /&gt; &lt;mapper resource=&quot;XXX.xml&quot;&gt; &lt;package name=&quot;com.misaniy.mapper&quot; /&gt; &lt;mappers&gt;&lt;/configuration&gt; ####Config.xml配置内容和顺序 properties(属性) settings(全局配置参数) typeAliases(类型别名) typeHandlers(类型处理器) objectFactory(对象工厂) plugins(插件) enviroments（环境集合属性对象） enviroments(环境子属性对象) -transactionManager -dataSource mappers（映射器） 4 PO类5 映射文件xxx.xml 1234567891011121314&lt;!-- &lt;mapper namespace=&quot;test&quot;&gt; 传统--&gt;&lt;mapper namespace=&quot;com.misaniy.UserMapper&quot;/&gt;&lt;!-- 使用Mapper不需要DaoImpl --&gt;&lt;!-- 这里的Type使用的别名，类型由mybatis内部定制，pojo由config配置文件定制--&gt;&lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;user&quot;&gt; select * from user where name like &apos;%$&#123;value&#125;%&apos;&lt;/select&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;After&quot; resultType=&quot;Integer&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(name) values(#&#123;name&#125;)&lt;/insert&gt;&lt;/mapper&gt; Mybatis解决jdbc的问题数据库链接和创建的频繁操作、sql硬编码、结果集封装到pojo、parameterType对输入参数的规范]]></content>
      <categories>
        <category>分享集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringWebMvc小结]]></title>
    <url>%2F2017%2F10%2F13%2FSpringWebMvc%2F</url>
    <content type="text"><![CDATA[学习SpringWebMvc的个人小结 SpringWebMvc执行流程 用户请求给前端控制器DispatcherServlet 前端控制器给HandlerMapping处理器映射器 处理器映射器根据映射找到Handler处理器 处理器返回ExcutionChain数据给前端控制器 前端控制器找到HandlerAdapter处理器适配器 处理器适配器找到处理器执行后返回ModelAndView给前端控制器 前端控制器把ModelAndView解析位Model和View，把Model赋值给View HandlerMapping ExcutionChain HandlerAdapter ModelAndView 视图解析器 解析Model赋值给View SpringMvc.xml配置文件 扫描Controller &lt; mvc:annotation-driver/&gt; 视图解析器 默认支持的数据类型 request response session Model ModelMap Map 基本数据类型 pojo类(属性名相同) 自定义参数类型 Converter 时间注解方式：pojo属性@DateTimeFormat(pattern=”yyyy-MM-dd”)]]></content>
      <categories>
        <category>分享集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java7的新特性Paths,Files]]></title>
    <url>%2F2017%2F09%2F25%2FJAVA7PathsFiles%2F</url>
    <content type="text"><![CDATA[在使用lucene 5的时候，发现在lucene4时file的地方用到了Path,发现这是JAVA7的新特性，于是查找相关文档，发现在IO方面,java7新增了Paths,Files工具类，发现异常强大，小结一下。 PathsPath是用来表示文件路径和文件，可以有多种方法来构造一个Path对象来表示一个文件路径或一个文件 在Paths类里有两个static方法 12345public static Path get(String first,String...more) &#123; return FileSystems.getDefault().getPath(first,more);&#125;public static Path get(Url url) 得到三种构造方式(以源文件d:/demo.txt为例) 1234Path path1 = Paths.get(&quot;d:/&quot;,&quot;demo.txt&quot;);Path path2 = Paths.get(&quot;d:/demo.txt&quot;);Path path3 = Paths.get(URI.create(&quot;file:///d:/demo.txt&quot;));Path path4 = FileSystems.getDefault().getPath(&quot;d:/&quot;,&quot;demo.txt&quot;); File和Path、File和URI之间的转换 12345File file = new File(&quot;d:/demo.txt&quot;);Path path = file.toPath();File file2 = path.toFile();URI uri = file.toURI(); 读取文件属性 1234567Path path = Paths.get(url);path.getFileName();path.getParent();//根目录path.getRoot();//目录级数(D:\xxx\xxx\xxx\demo.txt 4)path.getNameCount(); 创建一个文件 123Path path = Paths.get(&quot;C:\demo.txt&quot;);if(Files.exists(path)) Files.createFile(path); Files.newBufferWriter写入文件 1234BufferedWriter writer = Files.newBufferedWriter(Paths.get(&quot;D:\\demo.txt&quot;),Charset.forName(&quot;UTF-8&quot;)); writer.write(&quot;测试中文&quot;); writer.flush(); writer.close(); Files.newBufferWriter读取文件 123456BufferedReader reader = Files.newBufferedReader(Paths.get(&quot;D:\\demo.txt&quot;), Charset.forName(&quot;UTF-8&quot;)); String str = null; while((str = reader.readLine())!=null)&#123; System.out.println(str); &#125; reader.close(); 遍历文件夹,这里只遍历当前目录，不遍历子目录 12345678910111213Path path = Paths.get(&quot;D:\\dir&quot;); DirectoryStream&lt;Path&gt; paths = Files.newDirectoryStream(path); for(Path p : paths)&#123; System.out.println(p.getFileName()); &#125; DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(Paths.get(&quot;D:\\dir&quot;)); Iterator&lt;Path&gt; ite = stream.iterator(); while (ite.hasNext())&#123; Path path = ite.next(); System.out.println(path.getFileName()); &#125; 要遍历子目录，在java7前需要用递归，而java7的Files提供了walkFileTree()方法，这个在另一篇文章写到 Files 创建目录和文件 123Files.createDirectories(Paths.get(&quot;D://dir&quot;));if(!Files.exists(Paths.get(&quot;D://dir&quot;))) Files.createFile(Paths.get(&quot;D://dir/demo.txt&quot;)) 文件复制 123456789101112//Files.copy(Source,Target,CopyOptions) //StandardCopyOption //REPLACE_EXISTING 如果存在替换 //COPY_ATTRIBUTES 复制 //ATOMIC_MOVE Move the file as an atomic file system operation.//Files.copy(Source,OutputStream)//Files.copy(InputStream,Target,CopOption)Files.copy(Paths.get(&quot;C://Source.txt&quot;,Paths.get(&quot;D://Target.txt&quot;,StandardCopyOption.COPY_ATTRIBUTES))); 读取文件属性 123456789Path path = Paths.get(url);//最后一次修改时间 System.out.println(Files.getLastModifiedTime(path)); System.out.println(Files.size(path));//是否为一个连接 System.out.println(Files.isSymbolicLink(path)); System.out.println(Files.isDirectory(path));//指定属性，*表全部 System.out.println(Files.readAttributes(path,&quot;*&quot;));]]></content>
      <categories>
        <category>分享集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux误删除了备份的数据库]]></title>
    <url>%2F2017%2F09%2F13%2FOracleBankDelete%2F</url>
    <content type="text"><![CDATA[延迟加载异常：failed to lazily initialize a collection of role: com.misaniy.bos.domain.base.Courier.fixedAreas, could not initialize proxy - no Session reason：误删除了备份的数据库resolve：12345678910111213141516sqlplus /nolog//使用数据库命令模式connect system/root as sysdba//连接数据库SQL&gt;shutdown normal//关闭数据库oracle服务SQL&gt;startup mount//重新启动Oracle服务SQL&gt;alter database open;//打开数据库//SQL&gt;alter database datafile 5 offline drop 若出现错误SQL&gt;alter database open;//重新更改数据库的openSQL&gt;startup]]></content>
      <categories>
        <category>报错集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[could not initialize proxy - noSession]]></title>
    <url>%2F2017%2F09%2F13%2Flazily%2F</url>
    <content type="text"><![CDATA[failed to lazily initialize a collection of role: com.misaniy.xxx, could not initialize proxy - no Session延迟加载异常 解决方案有两种其一，在web.xml中配置Spring的OpenSessionInViewFilter，确保服务器端的逻辑执行完后再关闭session，这是针对hibernate的支持类12345678910111213&lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.jpa.support.OpenEntityManagerInviewFilter&lt;/filter-class&gt; &lt;!-- 如果你的sessionFactory不是叫sessionFactory，需要配置如下--&gt; &lt;init-param&gt; &lt;param-name&gt;sessionFactoryBeanName&lt;/param-name&gt; &lt;param-value&gt;&#123;Your Session Factory Name&#125;&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 其二，上面方法是hibernate的支持类，如果你配置的不是sessionFactory,比如我用的SPRING DATA JPA，就用如下方法1234@JSON(serialize = false)public XXX getXXX()&#123; return XXX;&#125; 在Bean类找到你的延迟加载的数据，没有使用到就使用该注解]]></content>
      <categories>
        <category>报错集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle和tomcat端口冲突]]></title>
    <url>%2F2017%2F09%2F12%2FPortException%2F</url>
    <content type="text"><![CDATA[Oracle XE http与tomcat端口冲突8080 reason：oracle与tomcat端口8080冲突，我们可以修改任意一个端口； resolve：修改oracle123sqlplus system/rootSQL&gt;call dbms_xdb.sethttpport(&apos;8082&apos;); 修改tomcat，这里由于用了maven,所以直接安装tomcat7插件Maven —&gt; build plugin —-&gt;tomcat712345678&lt;plugin&gt;&lt;gourpId&gt;org.apache.tomact.maven&lt;/groupId&gt;&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;&lt;version&gt;2.2&lt;/version&gt;&lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt;&lt;/configuration&gt; Run As —&gt; Maven InstallRun As —&gt; Maven Build… tomcat7:run]]></content>
      <categories>
        <category>分享集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全文检索和Lucene]]></title>
    <url>%2F2017%2F04%2F27%2FFull-Context%2F</url>
    <content type="text"><![CDATA[SQL语句的like会搜索大量不相关的内容，不走索引，且，存在资源浪费。这时我们就需要用到全文检索。 全文检索和Lucene全文检索了解Lucene之前，我们需要清楚全文检索的概念。 生活中的数据分为三种。 结构化数据：具有固定格式或有限长度的数据，如数据库，元数据等。 非结构化数据：不定长度或无固定格式的数据，如邮件，word文档等。 半结构化数据：根据需要可以按结构化数据处理，也可抽取出纯文本按非结构化数据来处理。 对应的搜索分为两种。 对结构化数据的搜索：sql语句、windows搜索文件名、类型、修改时间等 对非结构化数据的搜索：windwos搜索文件内容、linux的grep,搜索引擎的搜索等 对非结构化数据搜索即对全文数据的搜索分为两种： 顺序扫描法：假设寻找某个字符串的文件，就是一个文档一个文档读，然后每个文档从头读到尾，Linux下的grep就是这种方式，小数据量可以使用，但对于大量数据，就很慢了。 全文检索：将非结构化数据中的一部分信息提取出来，重新组织，使其变为结构化数据，我们称之为索引，而这种先建立索引，再搜索的过程就叫全文检索。 对应的创建索引方式分三种。 索引：加快数据搜索的一种数据结构 I/O流：对于本地文件创建索引。 爬虫：模拟访问URL，获取网页数据，搜索引擎使用。 SQL搜索：对于存放在数据库的数据使用。 如何创建索引 源文档Document 文档中包括一个一个域(Field)[file_name,file_path,file_size,file_content等] 分词组件Tokenizer得到词元Token 将源文档分词 去除标点 去除停词 处理组件LinguisticProcessor得到词Term 变为小写 缩减位词根 转变为词根 索引组件Indexer 用词Term创建字典 对字典按字母顺序排序 合并相同的词Term成为倒排索引(Posting List) 倒排索引：从字符串到文件的映射是文件到字符串映射的反向过程，所以这种索引称为倒排索引 如何对索引进行搜索 用户输入查询语句 对查询语句进行分析处理 搜索索引，得到符合语法树的文档 根据得到的文档和查询语句的相关性排序 LuceneLucene实现全文检索 获得原始文档 创建文档对象 分析文档 创建索引 查询索引库 常用域Field 创建索引库12 索引库的维护索引库的添加123456789//IndexWriterIndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(Path)),new IndexWriterConfig(Version.LATEST,new IKAnalyzer()));//Document.add(Field)Document document = new Document();document.add(new TextField(&quot;name&quot;,&quot;文档&quot;.Store.YES));document.add(new TextFiled(&quot;content&quot;,&quot;内容&quot;,Store.YES));IndexWriter.addDocument(document);IndexWriter.close(); 索引库的删除 删除全部 123456//IndexWriterIndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(Path)),new IndexWriterConfig(Version.LATEST,new IKAnalyzer()));//删除全部索引indexWriter.deleteAll();indexWriter.close(); 指定条件删除 12345678//IndexWriterIndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(Path)),new IndexWriterConfig(Version.LATEST,new IKAnalyzer()));//QueryQuery query = new TermQuery(new Term(&quot;name&quot;,&quot;文档&quot;));//指定条件删除indexWriter.deleteDocuments(query);indexWriter.close(); 索引库的修改123456789//IndexWriterIndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(Path)),new IndexWriterConfig(Version.LATEST,new IKAnalyzer()));//修改后的DocumentDocument document = new Document();document.add(new TextField(&quot;name&quot;,&quot;新文档&quot;,Store.YES));//updateDocumentindexWriter.updateDocument(new Term(&quot;content&quot;,&quot;文档&quot;),document);indexWriter.close(); 查询索引Query的子类查询TermQuery 精确查找123456789101112131415//IndexSearcherIndexSearcher indexSearcher = new IndexSearcher(Directory.open(FSDirectory.open(new File(Path))));Query query = new TermQuery(new Term(FieldName,keyStr));TopDocs topDocs = indexSearcher.searcher(query,100);//topDocs.scoreDocs存储了document的idfor(ScoreDoc scoreDoc : topDocs.scoreDocs)&#123; //scoreDoc.doc就是document的id Document document = indexSearcher.doc(scoreDoc.doc); document.get(keyStr);&#125;indexSearcher.getindexReader.close(); MatchAllDocsQuery 所有文档NumericRangeQuery 数值范围查找BooleanQuery 组合条件查找IndexSearcher搜索方法queryparser 查询QueryParserMulitFieldQueryParser TopDocs]]></content>
      <categories>
        <category>分享集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Solr安装与介绍]]></title>
    <url>%2F2017%2F04%2F02%2Fsolr%2F</url>
    <content type="text"><![CDATA[Solr是基于Lucene的全文搜索服务器 Solr的安装和配置Solr配置到tomcat 把Solr的war包赋值到tomcat的webapp下并解压 把Solr/example/lib/ext目录下的jar包添加到solr工程中. 配置SolrHome和SolrCore Solr/example/solr文件就是一个标准SolrHome，复制出来命名solrHome solrHome中的collection1就是一个SolrCore solrCore下有一个目录conf，conf下的solrconfig.xml可以配置相关信息。 solrconfig.xml env-entry-value:配置solrhome的绝对路径 Lib:solr服务依赖的拓展包 dataDir:配置索引库存放路径 requestHandler:查询时使用的url 打开Schema.xml可以看到Solr默认的FieldType class:Solr提供的包solr.TextField，solr.TextField允许用户通过分析器来定制索引和查询，分析器包括一个分词器(tokenizer)和多个过滤器(filter) positionIncrementGap:可选属性，定义在同一个文档中此类型数据的空白间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经验设置位100 analyzer 搜索分析器 solr.StandardTokenizerFactory 标准分词器 solr.StopFilterFactory 停用词过滤器 solr.LowerCaseFilterFactory 小写过滤器 索引分析器 solr.StandardTokenizerFactory 标准分词器 solr.StopFilterFactory 停用词过滤器 solr.SynonymFilterFactory 同义词过滤器 Field 定义 name 域名 type FieldType indexed 是否索引 stored 是否存储 multiValued 是否存储多个值 uniqueKey 默认定义唯一主键key为id域 &lt;uniqueKey&gt;id&lt;/uniqueKey&gt; copyField 复制域 将多个Field复制到一个Field中，进行统一检索 比如，输入关键字搜索name/description 1234567&lt;!-- 定义name/description/keywords的Field --&gt;&lt;field name=&quot;keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt;&lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;description&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;&lt;!-- 只搜索keywords就相当于搜索了name和description&lt;copyField source=&quot;name&quot; dest=&quot;keywords&quot;&gt;&lt;copyField source=&quot;description&quot; dest=&quot;keywords&quot;&gt; dynamicField(动态字段)自定义Field为:product_title_t&lt;dynamicField name=&quot;*_t&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; 配置中文分析器 将IKAnalyzer2012FF_ul.jar添加到solr/WEB-INF/lib 赋值IKAnalyzer的配置文件和自定义词典到solr的classpath下 在schema.xml中添加一个自定义的filedType 123&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextFiled&quot;&gt; &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt; 定义field，指定field的type属性为text_ik]]></content>
      <categories>
        <category>分享集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[我是谁Misaniy 这个名字是因为她的名字是YUANSIYI，我从中抠了几个字符串，加上我的想念组合的。 上可陪领导逛街拎包吃喝玩乐，下可宅在家里追新番，热衷于研究新菜品和更优雅的代码，也没有忘记工作之余锻炼身体给自己未来投资，有一个非常有眼光的女朋友（这绝不是在夸我），也在努力成为一个优雅的hentai绅士。 热爱生活，热爱科技，爱小米，更爱小米的智能家居体系，有朝一日，我要让家里充满智能，充满GEEK的味道。 这是哪里misaniy.cc这是我的博客小站，也是我的黄金屋。在我的代码之夜上，地上有数不清的咯脚的石子，我摸索着前行，背后总有一个人意味深长地让我带上他们。如果你听过这个故事，你也会像我一样，写这样一个博客，把一路的石子捡起来。 我会不时更新我的博客，在我代码上遇到问题，或者我觉得需要记录的时候 怎么联系我Github:MisaniyEmail:MisaniyWeibo:为这美好的世界献上祝福Location：中国.重庆]]></content>
  </entry>
</search>
